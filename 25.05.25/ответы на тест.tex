\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[top=2cm,bottom=3cm,left=2cm,right=2cm,nohead]{geometry}
\usepackage{amsmath}

\begin{document}

Считайте что это и есть тест

\section*{задачи на вещественные числа (не затрагивая прогу)}
\begin{enumerate}
    \item перечислите все необычные состояния вещественные числа float типа, когда они достигаются. на примере real32, real64
    \begin{enumerate}
        \item NaN:sNaN и qNaN (quit NaN, signing NaN)
        \item +inf, -inf,
        \item +0, -0 \\
        пример в half precision \\
        \begin{tabular}{c c|c c}
            $+\inf$ & 0 11111 00 0000 0000& $-\inf$& 1 11111 00 0000 0000\\
            sNaN & 0 11111 \b{0}0 0000 0001 & qNaN& 0 11111 \b{1}0 0000 0000\\
            +0 & 0 00000 00 0000 0000 & -0 & 1 00000 00 0000 0000\\
        \end{tabular}
    \end{enumerate}
    \item заполните табличку числом разрядов \\
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        стандарт& размер & бит знака & порядок & мантисса & bias \\
        \hline
        half precision & 16 & 1 & 5 & 10& 15\\
        \hline
        single precision & 32 & 1 & 8 & 23 & 127\\
        \hline
        double precision & 64 & 1 & 11 & 52 & \\
        \hline
        quad precision &128 & 1 & 15 & 112 & \\
        \hline
        extended precision &80& 1 & 15 & 64 & \\
        \hline
    \end{tabular}
    \item как громкий NaN (sNaN) переделать в тихий NaN (qNaN): Старший бит мантисы поставить на 1 
    \item что выдаст sqrt(-1.0f) ;;C код - лучший ответ sNaN - так как qNaN ставит только программист по своему усмотрению ответ NaN
    \item В каких случаях float может считаться денормализованным - если число $1.0*2^{bias}$ пример в половинной точности $2^{-15}$, хоть само число ещё вроде можно представить но так как все нули это 0, то мы будем записывать уже денормализованное число, те E=0 а старший бит Мантиссы есть 1 а не 1/2 \\
    ещё раз $2^{-15}$ будет записано как 0 00000 10 0000 00000 числа меньше также \\
    \item переведите в число единичной точности\\
    +0: 00000000 \\ 
    \\
    86.125 \\
    \begin{enumerate}
        \item $86.125_10 = 1010110.001_2=1.010110001_2*2^6$,
        \item bias = $2^{8-1}-1 = 127$, $E=6+127=133=10000101_2$
        \item итого запись: $0|1000 0101| 0101 1000 1000 0000 0000 000_2 = 42AC4000_{16}$
    \end{enumerate}
    196.75 \\
    приведу способ быстро проверить себя убедившись что числа действительно так хранятся в ассемблере, заодно закинув макросы:
\begin{verbatim}
include console.inc
include helpful.inc

.data
    pr real4 196.75
.code
Start:
    outbin pr
    newline
    outhex pr
    exit
end Start
\end{verbatim} 
    1/3 \\
    вспоминаем как нас научил Алексеев:\\
    \[ \frac{1}{3} \]
    \begin{tabular}{c|c}
        1 & 0, \\
        1*2=2, 2 mod 3 = 2 &2 div 3 = 0 \\
        2*2=4, 4 mod 3 = 1 &4 div 3= 1 \\
    \end{tabular} \\
    снова получили в остатке 1 значит мы зациклись получили запись $0.01010101(01)_2 = 1.01(01)*2^{-2}$ \\
    E = $-2+127=125=01111101_2$ \\
    получаем: $0 |0111 1101| 0101 0101 0101 0101 0101 01\underline{0} | \bf{1}01$ - необходимо округлить к ближайшему чётному мантиссу 0/1 $\rightarrow$ 0\\
    ответ: 0 0111 1101 0101 0101 0101 0101 0101 $010_2 = 3EAAAAAA_{16}$  \\
    \\
    -0 = $80000000_{16}$\\
    \\
    $20*2^{-128} = 1.01_2*2^4*2^{-128}$ \\
    порядок = -124: -124+127=3 \\
    ответ: 0 0000 0011 0100 0000 0000 0000 0000 000 \\
    \item сложите два числа half precision: \\
    890.5 + 10.5625 \\ \hangindent
    прокомментируйте все сдвиги поэтапно \par
    переведём числа в биты: \\
    890.5 = $1.1011110101_2*2^9$ = 0 11000 10 1111 0101$_2$ (a)\\
    10.5625 = $1.0101001_2*2^3$ = 0 10010 01 0100 1000$_2$ (b) \par
    разница между экспонентами $11000_2$ и $10010_2$ = 6\\
    сдвигаем мантиссу числа (b) на 6 стандарт IEEE-754 требует чтобы операции происходили с большей точностью
    \begin{flalign*}
        & 1.1011110101000 && (a) \\
        & 0.0000010101001 && (b) \\
        & 1.1100001010001 && \text{(a+b)}
    \end{flalign*}
    1.1100001010001 - нормализуем (уже нормализовано экспонента остаётся как у (a)) \\
    округляем на лекциях мы рассматривали стандартное банковское к ближайшему чётному \\
    1100001010 0 - первые 10 чисел после точки и 11 число  00 $\rightarrow$  0 \\
    получится число: 0 11000 1100001010 = 901\\
    \item решите уравнение считая что числа округление банковское single precision 
    98.3125+X=98.3125 \par
    98.3125 = 1100010.0101=1.1000100101*$2^6$ \\
    его запись будет $0\_10000101\_10001001010000000000000_2$ чтобы число не поменялось нужно прибавить что то маленькое по модулю чтобы после округления оно осталось таким же \\
    несложно понять что искомый X по модулю меньше $0.00000000000000000000001_2*2^6$(23 знака после точки) так как иначе мы бы увидели это в мантиссе после сложения\\
    так как округление банковское а последний разряд 0 то при любом исходе округляться будет в меньшую сторону -23+6=-17 $\rightarrow$ \
    \[ -2^{-17} < X < 2^{-17}\] НЕРАВЕНСТВА СТРОГИЕ!! \par
    решите это же самое уравнение уже в half precision, сравните результат \par
    98.3125 = 1100010.0101=1.1000100101*$2^6$ \\
    его запись будет 0 10101 1000100101 \\
    аналогично несложно понять что искомый X по модулю меньше $0.0000000001_2*2^6$(10 знаков после точки), но последний бит $\ne 0 \rightarrow$ \\
    возможно округление для это нужно чтобы число было больше или равен $0.00000000001_2*2^6$(11 знаков после точки) делаем вывод -11+6=-5
    \[ -2^{-5} < X < 2^{-5}\]\\
    \item достижение наибольшего и наименьшего значения float \\
    все единицы, но dec Порядок, иначе NaN (qNaN) - min\\
    все единицы, кроме 1 бита = 0 и dec Порядок, иначе NaN (qNaN) - max\\
\end{enumerate}
Ниже ответы на следующую часть

\newpage
\section*{задачи на ассемблере}
\begin{enumerate}
    \item Укажите разрядность XMM регистра, сколько их \par
    128 бит 8 штук
    \item Согласено соглашению (cdecl, stdcall) как передаётся вещественное число\par
    в вершине стека FPU в st0
    \item реализовать сложение, вычитание чисел (дополнительно умножение, деление) одинарной и двойной сложности используя SSE2
    \item Сложить NaN c любым другим числом
    \item Сравнить поведение qNaN и sNaN
    Если переопределить обработку прерывания то будет видно а так нам незаметно;
    \item Приведите операции что в результате дадут (real4 (single precision)):
    \begin{enumerate}
        \item +inf
        \item -inf
        \item NaN
        \item +0
        \item -0
    \end{enumerate}
    смотреть код
\end{enumerate}
\end{document}