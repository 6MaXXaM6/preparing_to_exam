;
; Задача. Дан массив А ссылок на номера ячеек.
; Требуется просуммировать все ячейки по
; всем ссылкам в массиве в переменную Z.
; Массив имеет длину N не более 16 элементов.
;
; Начало массива A располагается по адресу ff00.
; 
;
; A:  array of ^integer;
; 
; for index := 0 to N-1 do
; begin
;    Z := Z + A[index]^;
; end;
; 
; Переменные:
; Z - лежит в ячейке по адресу ffff
; N - лежит по адресу          fffe
;
; Для удобства записи в коментариях будем обозначать:
; [fffe] - доступ в память для ячейки c номером fffe.
;
; Запись данного файла не показывает процесс сочинения программы, использование
; временных имён, которые мы помещаем в ячейки, в том числе для частей команд.
; в дальнейшем имена в ячейках превращаются в числа.
; Здесь представлен уже конечный результат.
;
; По умолчанию временные переменные, и константы, которые понадобятся в ходе
; программирования будем помещать в конец памяти. Используя старшие адреса памяти в некотором
; роде в манере "стека", который растёт в сторону уменьшения адресов, с той разницей, что пока из
; такого "стека" мы ничего удалять не будем.
;
; В дальнейшем можно сделать дополнительный шаг преобразования программы: константы 
; переместить ближе к началу памяти сразу же за последней инструкцией программы.
; Здесь этот шаг проделан небыл.
;
; Использование памяти:
;    [ffff] - переменная Z
;    [fffe] - переменная N
;    [fffd] - константа 16
;    [fffc] - переменная index
;    [fffb] - константа 2^32  --  00 0001 0000 0000 -- (Используется для сдвигов)
;    [fffa] - константа 1
;
;
; Для удобстваперед командой слева будем записывать номер ячейки в которой она находится.
;
; в интересных случаях перед командой будет оставлен большой коментарий.  
;
;
;  Собственно сама программа:
;
0   95 fffe fffd 0002 ; сравниваем N с 16 и по <= перепрыгиваем останов программы с ошибкой.
1   99 0000 0000 0001 ; останов с ошибкой 1 - код ошибки (на доске было в старшем операнде инструкции).
2   02 fffc fffc fffc ; обнуляем index для цикла. [fffc] := [fffc]-[fffc]
3   94 fffc fffe 000c ; проверяем условие цикла. Если index >= N "выпрыгиваем" из цикла на ячейку c.

;
; Здесь вы вычисляем индекс ячейки массива A+index.  Результат поместим в ячейку 0.
; Она к текущему моменту уже не нужна, а для дальнейшей арифметики, с целью сформировать в памяти
; нужную команду пересылки так удобнее.
;
; стоит отметить, что в этом месте мы переписываем собственный код программы, что нормально для
; архитектуры Фон Неймана, но в общем случае будет недоступно в современных процессорах,
; как рпавило такое допускается для строго определённых небольших областей памяти. 
; Например таблицы plt (https://lvee.org/be/abstracts/280).
; Большие области памяти переписывает ядро операционной системы, по запросу программы через
; механизм системных вызовов к ядру операционной системы (темы 1-го семестра 2-го курса).
;
; [0000] := A + index 
;
4   01 ff00 fffc 0000

;
; Здесь мы формируем команду пересылки для доступа к элелемту массива.
; Для этого значение A+index, которое лежит в ячейке 0 в текущий момент умножаем на 2^32.
; смысл этого действия вместо a) получить b)
; a) 00 0000     0000 A+index  
; b) 00 A+index  0000 0000
;
; Если внимательно посмотреть, то b) это команда пересылки, которая поместит
; содержимое ячейки [A+index] в ячейку 0.
;
; тоесть: [0000] := [A+index]
;
; Вычисленное значение мы должны положить по адресу следующей команды, которая будет исполнена.
; это адрес 6.
;
; Здесь мы опять пользуемся свойством архитектуры Фон Неймана, а именно меняем свой код.
; формируем команду, которую будем исполнять далее.
;
5   13 0000 fffb 0006

;
; Значение в этой ячейке вообще не важно, так как оно будет переписано предыдущей инструкцией.
; для визуального выделения данного места просто заполним всё единичными битами.
; Можно наверно было заполнить нулями, но это не так "бросается в глаза".
;
; За счёт выполнения переписанной команды здесь получится [0000] := [A+index]
;
6   ff ffff ffff ffff

;
; Повторяем приём для формирования команды. Он необходим, так как A[index] на 
; самом деле является ссылкой на элемент.
;
; поэтому теперь в результате исполнения сформированной команды в ячейке 0
; значение по ссылке ()указателю).
; [0000] := A[index]^ 
;
; Замечание:
;   операция двойного разименования указателя на самом деле в программах происходит
;   достаточно часто при передаче адресов в фунции по var.   
;
7   13 0000 fffb 0008

8   ff ffff ffff ffff ; ячейка будет переписана для реализации [0000] := A[index]^

;
; прибавляем к Z содеримое ячейки до которой добрались с помощью предыдущей инструкции.
; 
; Z := Z + [0000]
;
9   01 ffff 0000 ffff

A   01 fffc fffa fffc ; увеличиваем счётчик цикла на единицу index := index + 1
B   80 0000 0000 0003 ; Переходим на проверку условия цикла. (проверка в ячейке 3)
С   99 0000 0000 0000 ; успешное завершение программы с кодом ошибки 0.

