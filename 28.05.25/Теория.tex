\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[top=2cm,bottom=3cm,left=0.5cm,right=2cm,nohead]{geometry}
\usepackage{multicol}

\begin{document}
\section*{всякое про КЭШ и конвейер}
\begin{enumerate}
    \item память стали делать таким образом, чтобы за одно обращение к ней она выдавала не по одному байту, а сразу по несколько байт с последовательными адресами. Для этого оперативную память разбивают на отдельные микросхемы, которые могут работать параллельно. Этот приём называют \textbf{расслоением памяти}
    \item теневые регистры - регистры что использует процессор, к ним нет доступа
    \item буфер комманд - буфер в который загружаются команды целом блоком, что позволяет анализировать контроллеру написанное
    \item множественность АЛУ - просто как факт АЛУ может быть несколько, тогда выполнение арифмтических операций возможно одновременно
    \item конвейерность устройств - определения
    \begin{enumerate}
        \item latency - задержка выполнения машинной команды, это число машинных тактов, которые требуется для полного выполнения команды (включая такты ожидания).
        \item throughput - пропускная способность, количество независимых комманд выполняемые одновременно
        \item время разгона конвейера - время которое требуется чтобы 1 команда прошла весь конвейер
    \end{enumerate}
    \item причины прерывания конвейера (возникновение пузырей - ступор конвейера)
    \begin{enumerate}
        \item данные на вход оказались неполными
        \item зависимость от дополнительных входов
    \end{enumerate}
    \item Можно, например, выделить следующие основные шаги выполнения команды:
    \begin{enumerate}
        \item Выбор команды
        \item Декодирование команды
        \item вычисление адресов операндов
        \item выбор операндов
        \item выполнение
        \item запись
    \end{enumerate}
    \item КЭШ память - память внутри процессора причём она есть у каждого ядра есть общие для нескоко ядер. Отсюда возникает проблема согласованности Кэша для нескольких процессорных функций
    \item L кэши разделяются по:
    \begin{enumerate}
        \item Размер
        \item Назначение (L[1|2|3])
        \item по организации отображения - прямое отображение LRU или ассоциативное отображение Full associative cache
    \end{enumerate}
    \item КЭШ линия или Кэш строка - данные в кэше относящиеся к одному блоку данных
    \item Промах - процессор не нашёл в кэше - промах
    \item Попадание - процессор нашёл в кэше что хотел
    \item Сквозная запись в кэше предполагает, что запись производится непосредственно в основную память (и дублируется в кэш), то есть запись не кэшируется. Преимущества такого подхода — быстрое получение, безопасность и полная согласованность данных. Недостатки — высокая нагрузка на кэш.
    \item Отложенная запись в кэше предполагает, что запись данных производится в кэш, а запись в основную память производится позже (при вытеснении или по истечении времени). Преимущества — высокая скорость записи данных. Недостатки — риск потери данных в случае аварийного завершения работы приложения до записи данных в основное хранилище.
    \item Прямое отображение - делим оперативную память на страницы их делим на блоки данных. в Кэше для каждой страницы есть место для 1 блока данных и его состояния, какой именно узнаётся благодаря префиксу. в случае попадания (мы ищем кэш линию соответственно страницы и видим, что номер блока данных совпадает) - заберём байт из КЭШа, при промахе (номер блока не совпал) мы обращаемся к памяти и записываем номер нового блока и данные в кэш линию.
    \item Ассоциативное отображение - в отличии от LRU в кэш линии - адрес, состояния - invalid modified stored , счётчик (обращений), данные и его. при попадании счёткик увеличивается, при промахе заменяется кэш линия с наименьшим значением счётчика
    \item Уровни кэшей - L1, L2, L3 - L1 у каждого ядра, L2 - у нескольких ядер одновременно, L3 - у всех один обращение происходит по иерархии
    \item предсказатель ветвлений -  При выполнении на конвейере команды условного перехода,
    делается предположение о том, выполнит ли эта команда переход или продолжится
    последовательное выполнение программы. В соответствие с этим предположением на конвейер
    выбираются команды из наиболее вероятной
    \item Что такое спекулятивное выполнение? - При выполнении на конвейере команды условного
    перехода, на конвейер поступают (и выполняются) команды обеих ветвей (программы). Когда же
    становится известно, следует или нет выполнять переход, учитывается результат выполнения
    команд нужной ветви; результат выполнения команд второй ветви отбрасывается
    \item Механизм реализации :
    \begin{enumerate}
        \item на абум
        \item согласно таблице переходов в которой у каждого ветвления есть 2 поля: число вызовов и число успешных переходов по их отношению выбирается наиболее вероятное спекулитивное выполнение
    \end{enumerate}
\end{enumerate}
\section*{Трансляция комманд}
Сальников добавил: \\
Зная что такое контроллер управления дешифрует что то
\begin{multicols}{2}
\noindent
код в ассемблере: \\
add byte[edx], 45 \\
\columnbreak \\
преобразуется контроллером В \\
mov тень$_i$, 45; константы подгружаем \\
load тень$_j$, edx; тень$_j$ $\leftarrow$ [edx] \\
add тень$_k$, тень$_j$, тень$_i$ \\
store edx, тень$_k$ 
\end{multicols}
load - внутренняя инструкция загрузки, store -внутренняя инструкция выгрузки в память\\
вся арифметика - 3 операторная \\ в процессе  счёта тень$_i$ могут переименовываються в eax, edx, ebx \\
другой пример: mov eax, X $\rightarrow$ mov тень$_i$, X; load eax, тень$_i$; X - метка \\
\section*{про прерывания}
читать Баулу \\ Стандартный пролог и эпилог:
\begin{verbatim}
    к сожелению не записал (надеемся на святика)
\end{verbatim}
вообще там чут чут написано в конспекте моём (последняя тема)
\section*{инструкции с 34 и 35 вопроса}
\begin{enumerate}
    \item префикс lock - гарантирует эксклюзивный доступ к памяти на время выполнения инструкции. (никто кроме этой инструкции не сможет одновременно обратиться к памяти)
    \item clwb [mem]- Cache Line Write Back записывает в память всю кэш-линию (обычно 64 байта), содержащую указанный адрес, 
    \item clflush [mem] - Cache Line Flush принудительно сбрасывающая содержимое кэш-линии в основную память и инвалидирующая (удаляющая) её из всех уровней кэша. Это ключевой инструмент для управления когерентностью кэша(согласованности кэша между ядрами) и работы с памятью, обходящей кэширование. аналогично сделает это с линией по адресу
    \item sfence (store fence) - Гарантирует, что все операции записи (store) в память, инициированные до барьера, завершатся до операций записи, начатых после барьера.
    \item lfence (load fence) - Гарантирует, что все операции чтения (load) из памяти, инициированные до барьера, завершатся до операций чтения, начатых после барьера.
    \item mfence (memory fence) - Комбинированный барьер: гарантирует порядок для и чтения, и записи. \\
    (fence - барьер)
    \item movnt\textit{xx} - инструкции записи в память минуя КЭШ
    \begin{enumerate}
        \item MOVNTI - целочисленное
        \item MOVNTPS - запись упакованных float (4*32) выравнивание 16
        \item MOVNTPD - запись упакованных float (2*64) выравнивание 16
        \item MOVNTDQ - запись целого числа 128 бит 16 байт выравнивание
    \end{enumerate}
    \item prefetch0 [mem] - загрузит в L0 L1 L2 кэши 
    \item prefetch1 [mem] - загрузит в L1 L2 кэши
    \item prefetch2 [mem] - загрузит в L3 кэш
    \item int n - n $\in [0, 255]$  обеспечивает программную генерацию прерывания и передачу управления в соответствующий обработчик.
    \item iret - Возврат из прерывания
\end{enumerate}
регистр флагов - IF (Interrupt Flags)
IF = 0 - на прерывение не реагирует \\
IF = 1 - на прерывание регирует \\
cli sti - ставит 0 и 1 соответсвенно\\
Idtr (interrupt description table register) указатель на Idt (interrupt description table) - таблицу\\
поля IDT:
\begin{enumerate}
    \item[1] используется или нет
    \item[2] адрес обработчика прерываний(виртуальный)
    \item[3] тип обработчика прерываний
    \item[4`] номер сегмента кода (где лежит обработчик прерываний) в GDT
    \item[4``] Номер TSS (task save segment) сегмента
    \item[5] DPL - desired privilege level
    \item[6] размер адреса 
\end{enumerate}
при возникновении прерывания оно может выполняться:
\begin{enumerate}
    \item на старом стеке
    \item на новом стеке
\end{enumerate}
В зависимости от уровни привелегий процессор сам может сбрасывать IF или нет \\
на старом стеке: программа выполнялась дошла до N иструкции произошло прерывание \\
\begin{enumerate}
\item старый CS, eflags и EIP кладём на стек в случае ошибки - информация о ней.
\item сменили сегмели (CS) на тот что в табличке
\item сменили EIP на тот что в табличке
\item CLI - аппаратно
\end{enumerate}
на новом стеке - всё то же самое но сохраняется SS и ESP сохраним: SS ESP CS eflags EIP *сообщение об ошибке* \\
также используется iret новый стек возьмём из TSS \\
в прерывании необходимо сохранить все регистры в случае использования TSS не надо. \\

\newpage
как строить табличку:
в строках команды и их нахождение на такт (номер строки)
\end{document}