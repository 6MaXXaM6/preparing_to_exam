Вариант: 1
Решил: Воронин Павел {a.k.a Pablito}
Группа: 110
Проверяющие: Кацкова О.Н и Пильщиков В.Н.
Оценка: 5
{баллов 54, но все найденные проверяющими ошибки исправлены}


1.
а) Абсолютный адрес - номер ячейки, ощитанный от начала оперативной памяти.
	{звучит тупо, но это определение зачли как правильное :))}
б) Неявный операнд - операнд, местоположение которого заранее известно и потому в команде явным образом не указывается.
в) Близкий переход - переход внутри одного сегмента.


2.
Команды выполнятся за 11 единиц времени.


3.
SF=0, CF=1, OF=1


4.
lea BX, T
mov CL, [BX]
xor CH, CH
jcxz L
mov SI, CX
mov byte ptr [BX][SI], 'T'
L:


5.
mov AX, 31A8h
mov ES, AX
mov BP, SP
xor SI,SI
mov CX, 501h
sub CX, SP
L:
mov AH, [BP][SI]
mov ES:[SI], AH
inc SI
loop L

6.
JDIF macro LN, M
local L
 irp P, <LN>
  if P lt 0
   cmp AX, P
   je L
  endif
 endm
jmp M
L:
endm
{если задача была решена без использования условного ассемблирования - например, с помощью cmp и команд перехода - то за задачу ставили 0 баллов}

7.
неправильные команды:
div 5 {нельзя делить на непосредственный операнд}
mov ES, DS {если 1-ый операнд - сегментный регистр, то 2-ой - только r16 илиm16}
add 800[SI], 15 {неясен размер операндов, нужно использовать ptr}
test 11b, CL {1-ый операнд не может быть непосредственным}
правильные команды:
lea bx, [bx] {1-ый операнд - r16, 2-ой - адресное выражение, так что всё OK, правда смыслу, как в NOP :))}
sub 15[SI], 800 {800 может быть только солвом, поэтому ptr здесь не нужно}

8.
public P {процедура должна быть объявлена как общая}
CODE segment {название сегмента команд - только CODE  или CSEG}
assume CS:CODE {в принципе, раз нет меток, то можно и без этого, но лучше написать - к этому придирались}
P proc far {процедура должна быть объявлена как дальняя}
 push BP; сохраняем значение BP
 mov BP, SP; устанавливаем BP на вершину стека
 push DS; сохраняем значение DS
 mov BX, [BP+6]; BX:=offs
 mov AX, [BP+8]; AX:=seg
 mov DS, AX; устанавливаем DS на начало сегмента, в котором расположена переменная
 inc byte ptr [BX]; A:=chr((ord(A)+1)mod 256) {прикольно, но на асме смотрится проще, чем на паскакале}
 pop DS; восстанавливаем значение DS 
 pop BP; восстанавливаем значение BP
{вызываемая из паскакаля процедура может гадить любые регистры, кроме DS, SS, SP и BP, так что на AX и BX мы можем положить, что я и сделал}
 ret 4; возвращаемся и очищаем стек
P endp
CODE ends
end
{народ, не забудьте 2 последние строчки, на этом много кто порезался}

9.
а) Внешние имена - имена, описанные вне данного модуля (в других модулях). В отличие от других имён, их адреса (сегменты и смещения) ассемблер определить не может и потому записывает нули на места их вхождения и заносит их в таблицу вхождения внешних имён, которую выносит в заголовок объектного модуля.
б) Каждое внешнее имя, используемое в модуле, должно быть указано в директивах вида: extrn <имя>:<тип>{,<имя>:<тип>}.

10.
Изменится 4-я строчка, она станет такой: (4) B8 27 01 8E.
SS=2701h
SP=0007h
CS=2700h
IP=0003h